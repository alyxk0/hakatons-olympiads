const int a = 150; //переменная, отвечающая за количество опросов датчика для среднеарифметического способа фильтрации
byte left[a]; //массив, хранящий значения левой руки за 150 опросов (переменная a) для среднеарифметического способа фильтрации
byte right[a]; //массив, хранящий значения правой руки за 150 опросов (переменная a) для среднеарифметического способа фильтрации
int maLeft, miLeft, ampLeft; //переменные отвечающие за хранение максимального, минимального и среднего значения из массива left
int maRight, miRight, ampRight; //переменные отвечающие за хранение максимального, минимального и среднего значения из массива right

int znach1, znach2, old_znach1, old_znach2; //переменные отвечающие за хранение текущего и предыдущего значения с датчика для левой и правой руки (1 - левая, 2 - правая)
double k1 = 0.1, k2 = 0.1; //сглаживающие коэффиценты для фильтра калмана (1 - для левой руки, 2 - для правой руки)

//фильтр калмана для левой руки, возвращающий отфильтрованное значение
int kalman_filtr_left (void) {
  znach1 = abs(analogRead(A0) - 512); //записываем абсолютное значение с датчика 
  znach1 = znach1 * k1 + (1 - k1) * old_znach1; //фильтрация
  old_znach1 = znach1; //сохраняем предыдущее значение
  return znach1;  
}

//фильтр калмана для правой руки, возвращающий отфильтрованное значение
int kalman_filtr_right (void) {
  znach2 = abs(analogRead(A1) - 512); //записываем абсолютное значение с датчика 
  znach2 = znach2 * k2 + (1 - k2) * old_znach2; //фильтрация
  old_znach2 = znach2; //сохраняем предыдущее значение
  return znach2;
}

//среднеарифметический фильтр для левой руки, возвращающий отфильтрованное значение
int sredn_filtr_left (void){
  for (int i = 0; i < a; i++){
    left[i] = map(analogRead(A0), 0, 1023, 0, 255); //записываем в массив left несколько значений с датчика (переменная a), отвечающего за левую руку
    delayMicroseconds(500);
  }
  miLeft = left[0];
  for (int i = 0; i < a; i++){
    if (miLeft >= left[i]) //находим минимальное значение массива left      
      miLeft = left[i];
  }
  maLeft = left[0];
  for (int i = 0; i < a; i++){
    if (maLeft <= left[i]) //находим максимальное значение массива left      
      maLeft = left[i];
  }
  ampLeft = maLeft - miLeft;  //вычисляем среднее значение за 150 опросов
  return ampLeft; 
}

//среднеарифметический фильтр для правой руки, возвращающий отфильтрованное значение
int sredn_filtr_right (void){
  for (int i = 0; i < a; i++){
    right[i] = map(analogRead(A1), 0, 1023, 0, 255); //записываем в массив right несколько значений с датчика (переменная a), отвечающего за правую руку
    delayMicroseconds(500);
  }
  miRight = right[0];
  for (int i = 0; i < a; i++){
    if (miRight >= right[i])      
      miRight = right[i]; //находим минимальное значение массива right      
  }
  maRight = right[0];
  for (int i = 0; i < a; i++){
    if (maRight <= right[i])      
      maRight = right[i]; //находим максимальное значение массива right     
  }
  ampRight = maRight - miRight; //вычисляем среднее значение за 150 опросов
  return ampRight; 
}



void setup() {
  Serial.begin(9600); //инициализируем Serial (скорость - 9600 бод)
}

void loop() {
  Serial.print(kalman_filtr_left()); //выводим в плоттер обработанный фильтром калмана сигнал с левой руки 
  Serial.print(',');
  Serial.print(kalman_filtr_right()); //выводим в плоттер обработанный фильтром калмана сигнал с правой руки 
  Serial.print(',');
  Serial.print(sredn_filtr_left()); //выводим в плоттер обработанный среднеарифметическим способом сигнал с левой руки 
  Serial.print(',');
  Serial.println(sredn_filtr_right()); //выводим в плоттер обработанный среднеарифметическим способом сигнал с правой руки   
}
